# High-Level Architecture

This document details the high-level architecture of the Gamevis system. The repository already contains pre-built JSDoc documentation at [docs/index.html](docs/index.html). However, it can be also be re-built manually with `npm run docs`.

## Database

### Configuration

The `config.json` file specifies what connection string Gamevis should use to connect to the Postgres database.   Gamevis expects to connect to a Postgres database of version 9.3 or later due to JSONB querying features.

```
{
	"connectionString": "postgres://user:pass@hostname:port/database"
}
```

### Schema

This section details the structure of the database tables that are automatically generated by the Gamevis importers and GUI.

Term | Description
-----|-------------
Level | Also known as a *map*, it is the *virtual environment* at which a game is played.
Entity | Any object within the virtual environment, from AI to players to debris, any object with a property is classed as an entity in Gamevis.
Event | An occurrence of an event at a particular time, optionally at one or more points in space.

#### session

Column | Type | Value
-------|------|-------
title | string, not null | User-friendly session title
level | string, not null | Name of the level/map/world this session was recorded from, e.g., `de_dust2`
game | string, not null | Short name of the game this session is associated with, e.g., `csgo`. This name will be used as the subdirectory to find the level overview data.
data | JSONB | (Optional) Custom data associated with this session.

#### event

This table represents events that occur throughout a game's session. Events are optionally associated with one or more locations within the game world, and optionally associated with one or more entities.

Column | Type | Value
-------|------|-------
session_id | foreign key | → session
tick | int, not null | Game tick that this event occurred
name | string, not null | Name of the event
data | JSONB, not null | Event-specific data. The data keys for a particular event name are expected to be constant across all instances of it being fired in a particular session
locations | JSONB | (Optional) All locations associated with this instance of the event. Keys should be a user-friendly string, and the value a `Vector2` object, e.g., `{'player': {'x': 500, 'y': 250}}`
entities | JSONB | (Optional) All entities associated with this instance of the event. Keys should be a user-friendly string, and the values pointers into the `entity_props` table, e.g., `{'grenade': 175, 'thrower': 11}`

#### entity_props

This table represents the entity properties throughout the recorded session.

Column | Type | Value
-------|------|-------
session_id | foreign key | → session
index | int, not null | Entity index. Does not have unique across an entire session, just for this entity at this tick
tick | int, not null | Game tick that this update occurred
prop | string, not null | Name of the property that was updated (e.g., `health`)
value | JSONB, not null | JSON object of the format `{'value': newValue}` representing the new value of the property.

## Importers

Gamevis supports two games for importers out-of-the-box:

Game | Path | Comments
-----|------|----------
Counter-Strike: Global Offensive | `importers/csgo` | Run `import.js` with the path to the demo file as the argument.
Dota 2: Reborn | `importers/dota_reborn` | Run `import.go` with the path to the `.dem` replay file as the argument.

The importers parse CS:GO and Dota 2 (Source 2) demo files respectively, parsing the data and then transforming it into the Gamevis database format. When developing new importers, use these existing importers as a reference implementation. Note that your importer can be developed completely separately to Gamevis, only a connection to the database is necessary.

## Front-end GUI

The front-end is an [Electron](http://electron.atom.io/) application written in JavaScript and Less using [Vue.js](https://vuejs.org/) (see `components/*.vue`). Note that when developing for Gamevis, `gulp watch` can be used to watch for changed Vue, Less or HTML files, rebuild them, and then refresh any open Gamevis windows.

Gamevis can also be launched with the `--dev` argument to specify that the developer tools should be opened on launch. This reduces the need to always open them manually when debugging the application. On the topic of debugging, it is highly recommended to use the in-built Chrome Developer Tools for debugging running JavaScript due to its high-quality support for sourcemaps and ease of use. 

### Overviews

Overviews for each level that is to be supported by Gamevis must reside at `overviews/<game name>/<level_name>`. A PNG image file of size 1024x1024px (other power-of-two sizes are also supported but untested), and a JSON file of the following structure must exist:

```
{
	"pos_x": -128, // World-space X coordinate of the top-left corner of the overview image
	"pos_y": 42, // World-space Y coordinate of the top-left corner of the overview image
	"scale": 5 // Scale of the overview image. e.g., 5 means 1 overview image pixel represents 5 world space units
}
```

The top-left corner of the overview image should have world-space coordinates of `[pos_x, pos_y]`, and the bottom-right corner `[pos_x + (1024 * scale), pos_y - (1024 * scale)]`.

### Vue component hierarchy

<img src="screenshot-hierarchy.png" width="1024">

The screenshot above shows how Vue.js components are nested within Gamevis. The properties of each component, including its available public methods, events fired/listened to, and props, are detailed in the JSDoc documentation under [docs/index.html](docs/index.html). Properties that are two-way (i.e., not simply inbound) are noted by the *two-way* tag before the property description.

### Adding a new visualisation

The component-based nature of the front-end framework, Vue, enables new components to be easily added to the system. To register a new visualisation in the system requires a few small addition to the code; in full:

1. Write the new visualisation code as a Vue component, saved in the `components` folder. For example, `components/VisBarChart.vue`.
2. Register the component with Vue in `app.js`. For example,
   `Vue.register('gv-vis-bar-chart', require('components/VisBarChart.vue'))`
3. Register the visualisation component in the `EventList` component, in the `types` array.
   For example, `{name: 'bar chart', component: 'gv-vis-bar-chart'}`

The visualisation components themselves have full access to the database, the freedom to add any HTML markup to allow users to specify options and filters, in addition to unrestricted access to the Node standard library.